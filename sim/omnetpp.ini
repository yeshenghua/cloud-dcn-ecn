[General]
network = dcn.SmallLeafSpine
sim-time-limit = 60s
repeat = 1
result-dir = ../results/${configname}
**.scalar-recording = true
**.vector-recording = true
output-scalar-file = ${resultdir}/omnetpp.sca
output-vector-file = ${resultdir}/omnetpp.vec

# Topology defaults
**.hostsPerLeaf = 3
**.ppp[*].delay = 2us
**.ppp[*].datarate = 10Gbps
**.ppp[*].queue.typename = "DropTailQueue"
**.ppp[*].queue.frameCapacity = 100

# TCP defaults
**.tcp.typename = "Tcp"
**.tcp.mss = 1460
**.tcp.ecn = false   # baseline: ECN off

# Flow definitions (generated)
include flows.inc

# ===== ECN via RedDropperQueue (fixed K) =====
# 打开 TCP 的 ECN（不同版本可能叫 ecn 或 ecnEnabled，都给）
**.tcp.ecn = true
**.tcp.ecnEnabled = true

# 把所有 PPP / Ethernet 接口队列类型换成 RedDropperQueue
**.ppp[*].queue.typename = "inet.queueing.queue.RedDropperQueue"
**.eth[*].queue.typename = "inet.queueing.queue.RedDropperQueue"

# 让 RED 变成“硬阈值”：q <= K 不触发；q > K 100% 触发
#（wq=1 表示不做平滑，maxp=1 表示到阈值直接触发）
**.ppp[*].queue.wq = 1
**.eth[*].queue.wq = 1
**.ppp[*].queue.maxp = 1
**.eth[*].queue.maxp = 1

# 如果这个队列支持 ECN 标记而不是丢包，通常是 markEcn / ecnMarking 等开关；
# 先试下面的名字（若启动时报 Unknown parameter，再把这两行删掉）：
**.ppp[*].queue.markEcn = true
**.eth[*].queue.markEcn = true

# 队列容量给大值，避免容量导致丢包（我们只想看 ECN 行为）
**.ppp[*].queue.packetCapacity = 1000000
**.eth[*].queue.packetCapacity = 1000000

# --- 三个 K 值（单位：包） ---
[Config k10]
extends = sym
**.ppp[*].queue.minth = 10
**.ppp[*].queue.maxth = 10
**.eth[*].queue.minth = 10
**.eth[*].queue.maxth = 10

[Config k30]
extends = sym
**.ppp[*].queue.minth = 30
**.ppp[*].queue.maxth = 30
**.eth[*].queue.minth = 30
**.eth[*].queue.maxth = 30

[Config k60]
extends = sym
**.ppp[*].queue.minth = 60
**.ppp[*].queue.maxth = 60
**.eth[*].queue.minth = 60
**.eth[*].queue.maxth = 60

# incast 版本
[Config incast8_k10]
extends = incast8, k10

[Config incast8_k30]
extends = incast8, k30

[Config incast8_k60]
extends = incast8, k60

[Config sym]
extends = General
description = "Symmetric baseline"

[Config incast8]
extends = General
description = "N=8 incast baseline (DropTail)"

# === 观察口校准 (RX=host[0]) ===
# host[0] 所在 leaf = floor(0/hostsPerLeaf) = 0
# leaf[0] 的 ppp 接口顺序：先接 spine[0] -> ppp[0], 再 spine[1] -> ppp[1],
# 然后主机 host[0], host[1], host[2] 依次成为 ppp[2], ppp[3], ppp[4]
# 因此 ToR 下行指向 RX(host[0]) 的队列是 leaf[0].ppp[2].queue
# 下面强制记录该方向的队列长度/比特长度向量（不同队列实现可能暴露不同统计名）。
**.leaf[0].ppp[2].queue.queueLength.result-recording-modes = +vector
**.leaf[0].ppp[2].queue.queueBitLength.result-recording-modes = +vector
# Fallbacks: 某些版本使用 queueByteLength / queuePacketLength
**.leaf[0].ppp[2].queue.queueByteLength.result-recording-modes = +vector
**.leaf[0].ppp[2].queue.queuePacketLength.result-recording-modes = +vector
# 若启动后出现 Unknown statistic，可忽略其中一行；至少会保留一个有效的。

# --- result defaults ---
result-dir = ../results/${configname}
**.scalar-recording = true
**.vector-recording = true
output-scalar-file = ${resultdir}/omnetpp.sca
output-vector-file = ${resultdir}/omnetpp.vec
