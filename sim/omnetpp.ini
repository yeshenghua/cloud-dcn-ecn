[General]
network = dcn.SmallLeafSpine
sim-time-limit = 60s
repeat = 1
result-dir = results/${configname}
**.scalar-recording = true
**.vector-recording = true
output-scalar-file = ${resultdir}/omnetpp.sca
output-vector-file = ${resultdir}/omnetpp.vec

# Topology defaults
**.hostsPerLeaf = 3
**.ppp[*].delay = 2us
**.ppp[*].datarate = 10Gbps
**.ppp[*].queue.typename = "DropTailQueue"
**.ppp[*].queue.frameCapacity = 100

# TCP defaults
**.tcp.typename = "Tcp"
**.tcp.mss = 1460
**.tcp.ecn = false   # baseline: ECN off

# Flow definitions (generated)
include flows.inc

# ===== ECN via RedDropperQueue (Route 1, no code) =====
# 注意：把 ECN/RED 改动限制在“ecn*”配置中，保持 baseline DropTail 不变。
[Config ecn]
extends = General
# 打开 TCP ECN（不同版本可能叫 ecn 或 ecnEnabled，都给上）
**.tcp.ecn = true
**.tcp.ecnEnabled = true

# 使用 RedDropperQueue 近似 Fixed-K（作为硬阈值：minth=maxth=K）
**.ppp[*].queue.typename = "inet.queueing.queue.RedDropperQueue"
**.eth[*].queue.typename = "inet.queueing.queue.RedDropperQueue"

# 关掉 EWMA（wq=0），并在达到阈值后 100% 动作（maxp=1）
**.ppp[*].queue.wq = 0
**.eth[*].queue.wq = 0
**.ppp[*].queue.maxp = 1
**.eth[*].queue.maxp = 1
**.ppp[*].queue.gentle = false
**.eth[*].queue.gentle = false

# 优先尝试“标记不丢包”（不同版本参数名可能不同，容错给法）
**.ppp[*].queue.markEcn = true
**.eth[*].queue.markEcn = true
**.ppp[*].queue.ecnMarking = true
**.eth[*].queue.ecnMarking = true

# 给足容量，避免容量导致的丢包（仅观察 ECN 行为）
**.ppp[*].queue.packetCapacity = 1000000
**.eth[*].queue.packetCapacity = 1000000

# --- 三个 K 值（单位：包） ---
[Config k10]
extends = ecn
**.ppp[*].queue.minth = 10
**.ppp[*].queue.maxth = 10
**.eth[*].queue.minth = 10
**.eth[*].queue.maxth = 10

[Config k30]
extends = ecn
**.ppp[*].queue.minth = 30
**.ppp[*].queue.maxth = 30
**.eth[*].queue.minth = 30
**.eth[*].queue.maxth = 30

[Config k60]
extends = ecn
**.ppp[*].queue.minth = 60
**.ppp[*].queue.maxth = 60
**.eth[*].queue.minth = 60
**.eth[*].queue.maxth = 60

[Config k120]
extends = ecn
**.ppp[*].queue.minth = 120
**.ppp[*].queue.maxth = 120
**.eth[*].queue.minth = 120
**.eth[*].queue.maxth = 120

# incast 版本
[Config incast8_k10]
extends = incast8, k10

[Config incast8_k30]
extends = incast8, k30

[Config incast8_k60]
extends = incast8, k60

[Config incast8_k120]
extends = incast8, k120

[Config sym]
extends = General
description = "Symmetric baseline"

[Config incast8]
record-eventlog = true
extends = General
description = "N=8 incast baseline (DropTail)"

# 全局打开向量
**.vector-recording = true

# 针对接收端 host[0] 的应用层统计（TcpSessionApp服务端会在 host[0].app[*]）
**.host[0].app[*].rcvdBytes.vector-recording = true
**.host[0].app[*].rcvdPk:vector(packetBytes).vector-recording = true
**.host[0].app[*].endToEndDelay.vector-recording = true

# N=16 incast baseline (flows generated by traffic_incast.py 16 ...)
[Config incast16]
extends = General
description = "N=16 incast baseline (DropTail)"

[Config incast16_k10]
extends = incast16, k10

[Config incast16_k30]
extends = incast16, k30

[Config incast16_k60]
extends = incast16, k60

# === 观察口校准 (RX=host[0]) ===
# host[0] 所在 leaf = floor(0/hostsPerLeaf) = 0
# leaf[0] 的 ppp 接口顺序：先接 spine[0] -> ppp[0], 再 spine[1] -> ppp[1],
# 然后主机 host[0], host[1], host[2] 依次成为 ppp[2], ppp[3], ppp[4]
# 因此 ToR 下行指向 RX(host[0]) 的队列是 leaf[0].ppp[2].queue
# 下面强制记录该方向的队列长度/比特长度向量（不同队列实现可能暴露不同统计名）。
**.leaf[0].ppp[2].queue.queueLength.vector-recording = true
**.leaf[0].ppp[2].queue.queueBitLength.vector-recording = true
# Fallbacks: 某些版本使用 queueByteLength / queuePacketLength
**.leaf[0].ppp[2].queue.queueByteLength.vector-recording = true
**.leaf[0].ppp[2].queue.queuePacketLength.vector-recording = true
# 若启动后出现 Unknown statistic，可忽略其中一行；至少会保留一个有效的。

# --- result defaults ---
result-dir = results/${configname}
**.scalar-recording = true
**.vector-recording = true
output-scalar-file = ${resultdir}/omnetpp.sca
output-vector-file = ${resultdir}/omnetpp.vec

# ==== FCT Observability (receiver host[0]) ====
# Fast fallback: event log (large size but complete ordering of packet events)
record-eventlog =  true

# Prefer explicit per-app statistics on RX (host[0]) to derive flow completion time.
# Different INET versions expose slightly different names; enable broadly (unknown ones ignored).
**.host[0].app[*].statistic-recording = true
# Version group 1 (packet receive vectors with bytes attribute)
**.host[0].app[*].rcvdPk:vector(packetBytes).enabled = true
**.host[0].app[*].rcvdPk:vector(packetBytes).record = true
# Version group 2 (direct byte counters)
**.host[0].app[*].rcvdBytes:vector.record = true
# Version group 3 (end-to-end latency if available)
**.host[0].app[*].endToEndDelay:vector.record = true

# Additional per-packet receive/send vectors for FCT derivation (create time series of arrivals)
**.host[0].app[*].packetReceived.result-recording-modes = +vector
**.host[0].app[*].packetSent.result-recording-modes = +vector
**.host[0].app[*].packetReceived:vector(packetBytes).enabled = true
**.host[0].app[*].packetReceived:vector(packetBytes).record = true
**.host[0].app[*].packetSent:vector(packetBytes).enabled = true
**.host[0].app[*].packetSent:vector(packetBytes).record = true

# ==== Asymmetric link (example override; requires EthChan channel) ====
# NOTE: After replacing channel type in NED to EthChan, uncomment one of the following lines to
# introduce a 5Gbps bottleneck (example: leaf[2] uplink first ppp port to spine[0]).
# *.leaf[2].ppp[0].channel.datarate = 5Gbps
